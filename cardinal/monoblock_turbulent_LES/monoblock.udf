//
// nekRS User Defined File
//

// -----------------------------------------------------------
// Standard includes and declarations
// -----------------------------------------------------------

static dfloat R_PIPE;
static dfloat U_INIT;
static dfloat C_X0;
static dfloat C_Y0;
static dfloat C_Z0;

#include "udf.hpp"
#ifdef __okl__
// source the user-defined OCCA kernels
#include "monoblock.oudf"
#endif
// time-averaging plugin
#include "plugins/tavg.hpp"

// -----------------------------------------------------------
// Core NekRS functions
// -----------------------------------------------------------

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  // Pass parameters defined in .par/[CASEDATA] to the kernels defined in the .oudf file
  kernelInfo["defines/rPipe"]   = R_PIPE;
  kernelInfo["defines/uInit"]	= U_INIT;
  kernelInfo["defines/cx0"]	= C_X0;
  kernelInfo["defines/cy0"]	= C_Y0;
  kernelInfo["defines/cz0"]	= C_Z0;
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  // called once before initialising NekRS

  // load custom parameters set in .par/[CASEDATA]
  //
  // note:
  // - 2nd argument is name in [CASEDATA],
  // - 3rd is a variable declared in .udf where the value will be stored (see top of file)
  //
  platform->par->extract("casedata","r_pipe",R_PIPE);
  platform->par->extract("casedata","u_init",U_INIT);
  platform->par->extract("casedata","c_x0",C_X0);
  platform->par->extract("casedata","c_y0",C_Y0);
  platform->par->extract("casedata","c_z0",C_Z0);
}


dfloat parabolic_vel(dfloat u, dfloat r, dfloat rPipe)
{
  // calculate parabolic velocity profile
  return -(u)*(1 - ((r*r)/(rPipe*rPipe)));
}

void UDF_Setup(nrs_t* nrs)
{
  // Called once after initialising the mesh, boundary fields etc.
  mesh_t * mesh = nrs->cds->mesh[0];

  // setup time-averaging plugin
  tavg::setup(nrs);

  // -----------------------------------------------------------
  // Initial Conditions
  // -----------------------------------------------------------

  int n_gll_points = mesh->Np * mesh->Nelements;
  for (int n = 0; n < n_gll_points; ++n) {
    // set wavenumbers
    static dfloat kx = 5*M_PI/R_PIPE;
    static dfloat ky = kx;
    static dfloat kz = kx;
    static dfloat kd2 = 2*(M_PI/(2*R_PIPE));
    static dfloat kd16 = 16*(M_PI/(2*R_PIPE));
    static dfloat kL30 = 30*(M_PI/30);
      
    // get gll point coordinates    
    dfloat x = mesh->x[n] - C_X0;
    dfloat y = mesh->y[n] - C_Y0;
    dfloat z = mesh->z[n] - C_Z0;
    dfloat r = sqrt(x*x + y*y);
      
    // parabolic axial profile
    dfloat u_z_0 = parabolic_vel(U_INIT, r, R_PIPE);

    // axial perturbation
    dfloat zAxialMod = sin(kL30*(z + 15));
    dfloat zRadialPerturb = sin(kd16*(r+R_PIPE));
    dfloat u_z_p = 0.1 * zAxialMod * zRadialPerturb;

    // transverse perturbation
    dfloat xTransvMod = sin(kd2*(r + R_PIPE));
    dfloat xPerturb = sin(kx*x) * sin(ky*y) * sin(kz*z);
    dfloat u_x_p = 0.1 * xTransvMod * xPerturb;
    dfloat u_y_p = u_x_p;

    nrs->U[n + 0 * nrs->fieldOffset] = u_x_p; // x-velocity
    nrs->U[n + 1 * nrs->fieldOffset] = u_y_p; // y-velocity
    nrs->U[n + 2 * nrs->fieldOffset] = u_z_0 + u_z_p; //z-velocity

    nrs->P[n] = 0.0; // pressure

    nrs->cds->S[n + 0 * nrs->fieldOffset] = 0.0; // temperature
  }
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  mesh_t *mesh = nrs->meshV;

  // compute time-averaged values
  tavg::run(time);
  // periodically writeout time-averaged values
  if (nrs->isOutputStep) {
    tavg::outfld();
  }
}

