//
// nekRS User Defined File
//
#include "udf.hpp"

// -----------------------------------------------------------
// RANS k-tau includes
// -----------------------------------------------------------

#include "plugins/RANSktau.hpp"

// -----------------------------------------------------------
// RANS k-tau declarations
// -----------------------------------------------------------

static dfloat rho, mueLam;

// -----------------------------------------------------------
// General user declarations
// -----------------------------------------------------------
static dfloat R_PIPE;
static dfloat U_INIT;
static dfloat U_INFLOW;
static dfloat T_INFLOW;
static dfloat T_HEATER;
static dfloat T_INIT;
static dfloat C_X0;
static dfloat C_Y0;

#ifdef __okl__

#include "pipe.oudf"

#endif

// -----------------------------------------------------------
// RANS k-tau functions
// -----------------------------------------------------------

void userq(nrs_t *nrs, dfloat time, occa::memory o_S, occa::memory o_FS)
{
  // RANS k-tau user source terms
  mesh_t *mesh = nrs->meshV;
  cds_t *cds = nrs->cds;

  RANSktau::updateSourceTerms();
}

void uservp(nrs_t *nrs,
            dfloat time,
            occa::memory o_U,
            occa::memory o_S,
            occa::memory o_UProp,
            occa::memory o_SProp)
{
  // RANS k-tau user variable properties
  mesh_t *mesh = nrs->meshV;
  cds_t *cds = nrs->cds;

  RANSktau::updateProperties();

  dfloat conductivity;
  platform->options.getArgs("SCALAR00 DIFFUSIVITY", conductivity);
  const dfloat Pr_t = 0.7;
  occa::memory o_mue_t = RANSktau::o_mue_t();
  occa::memory o_temp_mue = cds->o_diff + 0 * cds->fieldOffset[0] * sizeof(dfloat);
  scalarScaledAdd(mesh->Nlocal, conductivity, 1 / Pr_t, o_mue_t, o_temp_mue);
}

// -----------------------------------------------------------
// General user functions
// -----------------------------------------------------------

dfloat velocity_profile(dfloat u, dfloat x0, dfloat y0, dfloat x, dfloat y, dfloat rPipe)
{
  // calculate parabolic velocity profile
  return -(u)*(1 - (( ((x-x0)*(x-x0))+((y-y0)*(y-y0)) )/(rPipe*rPipe)));
}

// -----------------------------------------------------------
// Core NekRS functions
// -----------------------------------------------------------

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
}

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  // Send parameters specified in .par file to .oudf file (device kernels)
  kernelInfo["defines/rPipe"]		= R_PIPE;
  kernelInfo["defines/uInflow"]	= U_INFLOW;
  kernelInfo["defines/TInflow"]	= T_INFLOW;
  kernelInfo["defines/THeater"]	= T_HEATER;
  kernelInfo["defines/cx0"]			= C_X0;
  kernelInfo["defines/cy0"]			= C_Y0;
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  // Extract custom parameters specified in .par file
  platform->par->extract("casedata", "r_pipe", R_PIPE);
  platform->par->extract("casedata", "u_init", U_INIT);
  platform->par->extract("casedata", "u_inflow", U_INFLOW);
  platform->par->extract("casedata", "T_inflow", T_INFLOW);
  platform->par->extract("casedata", "T_heater", T_HEATER);
  platform->par->extract("casedata", "T_init", T_INIT);
  platform->par->extract("casedata", "c_x0", C_X0);
  platform->par->extract("casedata", "c_y0", C_Y0);
}

void UDF_Setup(nrs_t* nrs)
{
  // -----------------------------------------------------------
  // RANS k-tau setup
  // -----------------------------------------------------------
  udf.properties = &uservp;
  udf.sEqnSource = &userq;

  // increase this accordingly if additional scalars are included before k and tau
  const int scalarFieldStart = 1;     // scalar ID for k
  platform->options.getArgs("VISCOSITY", mueLam);
  platform->options.getArgs("DENSITY", rho);

  RANSktau::setup(nrs, mueLam, rho, scalarFieldStart);

  // -----------------------------------------------------------
  // Initial conditions (ICs)
  // -----------------------------------------------------------

  // Set initial conditions unless a restart file is being used
  if (platform->options.getArgs("RESTART FILE NAME").empty()){

    // set initial conditions for the velocity, temperature, and pressure
    mesh_t * mesh = nrs->meshV;

    // loop over all the GLL points and assign values to the solution arrays
    int n_gll_points = mesh->Np * mesh->Nelements;

    for (int n = 0; n < n_gll_points; ++n)
    {
      // calculate parabolic velocity profile using custom function
      dfloat u_z_0 = velocity_profile(U_INIT, C_X0, C_Y0, mesh->x[n], mesh->y[n], R_PIPE);

      // apply a perturbation to parabolic profile

      // set wavenumbers
      static dfloat kx = 5*M_PI/R_PIPE;
      static dfloat ky = kx;
      static dfloat kz = kx;
      static dfloat kd2 = 2*(M_PI/(2*R_PIPE));
      static dfloat kd16 = 16*(M_PI/(2*R_PIPE));
      static dfloat kL30 = 30*(M_PI/30);

      // get mesh coordinates
      dfloat x = mesh->x[n] - C_X0;
      dfloat y = mesh->y[n] - C_Y0;
      dfloat z = mesh->z[n];
      dfloat r = sqrt(x*x + y*y);

      // axial perturbation
      dfloat zAxialMod = sin(kL30*(z + 15));
      dfloat zRadialPerturb = sin(kd16*(r+R_PIPE));
      dfloat u_z_p = 0.1 * zAxialMod * zRadialPerturb;

      // transverse perturbation
      dfloat xTransvMod = sin(kd2*(r + R_PIPE));
      dfloat xPerturb = sin(kx*x) * sin(ky*y) * sin(kz*z);
      dfloat u_x_p = 0.1 * xTransvMod * xPerturb;
      dfloat u_y_p = u_x_p;

      // set initial velocity
      nrs->U[n + 0 * nrs->fieldOffset] = u_x_p;
      nrs->U[n + 1 * nrs->fieldOffset] = u_y_p;
      nrs->U[n + 2 * nrs->fieldOffset] = u_z_0 + u_z_p;

      // set initial pressure
      nrs->P[n] = 0.0;

      // set initial temperature
      nrs->cds->S[n] = T_INIT;
    }
  }
}
