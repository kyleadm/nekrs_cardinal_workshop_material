//
// nekRS User Defined File
//
#include "udf.hpp"

// -----------------------------------------------------------
// RANS k-tau includes
// -----------------------------------------------------------

#include "plugins/RANSktau.hpp"

// -----------------------------------------------------------
// RANS k-tau declarations
// -----------------------------------------------------------

static double rho, mueLam;

// -----------------------------------------------------------
// General user declarations
// -----------------------------------------------------------
static double C_X0;
static double C_Y0;
static double R_PIPE;
static double U_INIT;
static double U_INFLOW;
static double T_INFLOW;
static double T_HEATER;
static double T_INIT;
static double K_INIT;
static double TAU_INIT;

#ifdef __okl__

#include "pipe.oudf"

#endif

// -----------------------------------------------------------
// RANS k-tau functions
// -----------------------------------------------------------

void userq(double time)
{
  // RANS k-tau user source terms
  RANSktau::updateSourceTerms();
}

void uservp(double time)
{
  // RANS k-tau user variable properties
  auto mesh = nrs->meshV;
  auto& scalar = nrs->scalar;

  RANSktau::updateProperties();

  double conductivity;
  platform->options.getArgs("SCALAR00 DIFFUSIVITY", conductivity);
  const double Pr_t = 0.7;
  scalarScaledAdd(mesh->Nlocal, conductivity, 1 / Pr_t, RANSktau::o_mue_t(), scalar->o_diffusionCoeff("temperature"));
  // note - this is assuming nondimensional setup where rho=Cp=1.
  // If not, Cp is also needed in this calculation
  // Exposed to the user so different constitutive models can be chosen for the mu, kappa relation
}

// -----------------------------------------------------------
// General user functions
// -----------------------------------------------------------

double velocity_profile(double u, double x0, double y0, double x, double y, double rPipe)
{
  // calculate parabolic velocity profile
  return -(u)*(1 - (( ((x-x0)*(x-x0))+((y-y0)*(y-y0)) )/(rPipe*rPipe)));
}

// -----------------------------------------------------------
// Core NekRS functions
// -----------------------------------------------------------

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  // Extract custom parameters specified in .par file
  platform->par->extract("casedata", "r_pipe", R_PIPE);
  platform->par->extract("casedata", "u_init", U_INIT);
  platform->par->extract("casedata", "u_inflow", U_INFLOW);
  platform->par->extract("casedata", "T_inflow", T_INFLOW);
  platform->par->extract("casedata", "T_heater", T_HEATER);
  platform->par->extract("casedata", "T_init", T_INIT);
  platform->par->extract("casedata", "k_init", K_INIT);
  platform->par->extract("casedata", "tau_init", TAU_INIT);
  platform->par->extract("casedata", "c_x0", C_X0);
  platform->par->extract("casedata", "c_y0", C_Y0);
}

void UDF_LoadKernels(deviceKernelProperties& kernelInfo)
{
  // Send parameters specified in .par file to .oudf file (device kernels)
  kernelInfo.define("rPipe") = R_PIPE;
  kernelInfo.define("uInflow") = U_INFLOW;
  kernelInfo.define("TInflow") = T_INFLOW;
  kernelInfo.define("THeater") = T_HEATER;
  kernelInfo.define("cx0") = C_X0;
  kernelInfo.define("cy0") = C_Y0;
}

void UDF_Setup()
{
  // -----------------------------------------------------------
  // RANS k-tau setup
  // -----------------------------------------------------------
  nrs->userProperties = &uservp;
  nrs->userSource = &userq;

  // Set up RANS k-tau, using nameToIndex to get the ID of the k scalar
  // Assumes tau is immediately after k in .par [GENERAL] scalars list
  RANSktau::setup(nrs->scalar->nameToIndex.find("k")->second);

  // -----------------------------------------------------------
  // Initial conditions (ICs)
  // -----------------------------------------------------------

  // Set initial conditions unless a restart file is being used
  if (platform->options.getArgs("RESTART FILE NAME").empty()){

    // get mesh data
    auto mesh = nrs->meshV;
    auto [x, y, z] = mesh->xyzHost(); // x[n], y[n], z[n]

    // define vectors for setting intermediate U, P, T, k and tau
    std::vector<dfloat> U(mesh->dim * nrs->fieldOffset, 0.0);
    std::vector<dfloat> P(nrs->fieldOffset, 0.0);
    std::vector<dfloat> T(mesh->Nlocal);
    std::vector<dfloat> k(mesh->Nlocal, 0.0);
    std::vector<dfloat> tau(mesh->Nlocal, 0.0);

    // loop over all the GLL points and assign values to the solution arrays
    for (int n = 0; n < mesh->Nlocal; n++) {
      // calculate parabolic velocity profile using custom function
      double u_z = velocity_profile(U_INIT, C_X0, C_Y0, x[n], y[n], R_PIPE);

      // set initial velocity, pressure and temperature
      U[n + 0 * nrs->fieldOffset] = 0.0;
      U[n + 1 * nrs->fieldOffset] = 0.0;
      U[n + 2 * nrs->fieldOffset] = u_z;
      P[n] = 0.0;
      T[n] = T_INIT;
      k[n] = K_INIT;
      tau[n] = TAU_INIT;
    }

    // copy intermediate U, P and T to velocity, pressure and temperature on device
    nrs->fluid->o_U.copyFrom(U.data(), U.size());
    nrs->fluid->o_P.copyFrom(P.data(), P.size());
    nrs->scalar->o_solution("temperature").copyFrom(T.data(), T.size());
    nrs->scalar->o_solution("k").copyFrom(k.data(), k.size());
    nrs->scalar->o_solution("tau").copyFrom(tau.data(), tau.size());
  }
}

void UDF_ExecuteStep(double time, int tstep)
{
}